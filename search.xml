<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洛谷P2596 [ZJOI2006]书架]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%B4%9B%E8%B0%B7P2596-ZJOI2006-%E4%B9%A6%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[思路在这里提供一种新思路，不同于子树合并。虽然效率会低一些，但复杂度是对的 我们虚拟一个节点高度，把高度作为数列进行维护 其实很好想 T：删除编号为S的书，插入一个虚拟高度为当前最小且编号为S的书 B：同T，插入虚拟高度为当前最大 I：交换前驱或后继的信息 A：查询rank Q：查询kth 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;const int maxn=1000000+100;int ch[maxn][2],fa[maxn],size[maxn],cnt[maxn],id[maxn],val[maxn],pos[maxn];char op[10];//id表示节点编号，val表示节点虚拟高度,pos表id所在位置 int root,ncnt;int mi,mx;inline int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return x*f;&#125;void output(int u=root)&#123; if(ch[u][0])output(ch[u][0]); if(val[u]==inf||val[u]==-inf)return; printf("%d ",id[u]); if(ch[u][1])output(ch[u][1]);&#125;void pushup(int u)&#123; size[u]=size[ch[u][0]]+size[ch[u][1]]+cnt[u];&#125;int chk(int u)&#123; return ch[fa[u]][1]==u;&#125;void rotate(int u)&#123; int f=fa[u],ff=fa[f],k=chk(u),s=ch[u][k^1]; ch[f][k]=s,fa[s]=f; ch[ff][chk(f)]=u,fa[u]=ff; ch[u][k^1]=f,fa[f]=u; pushup(u),pushup(f);&#125;void splay(int u,int goal=0)&#123; while(fa[u]!=goal) &#123; int f=fa[u],ff=fa[f]; if(ff!=goal) &#123; if(chk(u)==chk(f))rotate(f); else rotate(u); &#125; rotate(u); &#125; if(!goal)root=u;&#125;void insert(int x,int y)&#123; int u=root,f=0; while(u&amp;&amp;val[u]!=x) f=u,u=ch[u][x&gt;val[u]]; u=++ncnt; if(f)ch[f][x&gt;val[f]]=u; fa[u]=f,val[u]=x,id[u]=y,pos[y]=u; size[u]=cnt[u]=1; ch[u][0]=ch[u][1]=0; splay(u);&#125; int kth(int k)&#123; int u=root; while(1) &#123; if(ch[u][0]&amp;&amp;k&lt;=size[ch[u][0]]) u=ch[u][0]; else if(k&gt;size[ch[u][0]]+cnt[u]) k-=size[ch[u][0]]+cnt[u],u=ch[u][1]; else return u; &#125;&#125;int ask(int x)&#123; splay(pos[x]); return size[ch[root][0]]-1;&#125;int pre(int u)&#123; splay(u); u=ch[root][0]; while(ch[u][1])u=ch[u][1]; return u;&#125;int succ(int u)&#123; splay(u); u=ch[root][1]; while(ch[u][0])u=ch[u][0]; return u;&#125;void remove(int u)&#123; int last=pre(u),next=succ(u); splay(last),splay(next,last); ch[next][0]=0;&#125;void top(int s)&#123; remove(pos[s]); insert(--mi,s);&#125;void bottom(int s)&#123; remove(pos[s]); insert(++mx,s);&#125;void change(int u,int o)&#123; int now=pos[u]; if(o==1) &#123; int next=succ(now); if(!id[next])return; pos[u]=next,pos[id[next]]=now;//出错几次死在这里 swap(id[now],id[next]); &#125; if(o==-1) &#123; int last=pre(now); if(!id[last])return; pos[u]=last,pos[id[last]]=now; swap(id[now],id[last]); &#125; &#125;int main()&#123; insert(inf,0),insert(-inf,0); int n=read(),m=read(); mi=0,mx=n+1; for(int i=1;i&lt;=n;i++) insert(i,read()); for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;op; if(op[0]=='T')&#123;int x=read();top(x);&#125; if(op[0]=='B')&#123;int x=read();bottom(x);&#125; if(op[0]=='I')&#123;int x=read(),y=read();change(x,y);&#125; if(op[0]=='A')&#123;int x=read();printf("%d\n",ask(x));&#125; if(op[0]=='Q')&#123;int x=read();printf("%d\n",id[kth(x+1)]);&#125; &#125; return 0;&#125; 主要是因为太蒻，一篇题解也没看懂]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hallo World]]></title>
    <url>%2F2019%2F07%2F12%2FHallo-World%2F</url>
    <content type="text"><![CDATA[有野心的GCP最喜欢的番《鋼の錬金術師》最喜欢的歌《Again》最喜欢的角色”衛宮士郎”梦想，最喜欢的人 ないしょ]]></content>
  </entry>
</search>
